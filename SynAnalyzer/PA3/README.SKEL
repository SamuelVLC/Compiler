README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA3/Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [course dir]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [course dir]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [course dir]/src/PA3/dumptype.cc
 handle_flags.c           -> [course dir]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [course dir]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [course dir]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [course dir]/src/PA3/tokens-lex.cc
 tree.cc		  -> [course dir]/src/PA3/tree.cc
 utilities.cc		  -> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% gmake parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% gmake dotest

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% gmake submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files cool.y, good.cl, bad.cl,
	good.output, bad.output, and README. Don't forget to edit the
	README file to include your write-up, and to write your own test
	cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	If you change architectures you must issue

	% gmake clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

Em geral, junto a leitura e análise dos Manuais de Bison e Cool Manual encontrado no link https://theory.stanford.edu/~aiken/software/cool/cool-manual.pdf foi possível definir a formalidade do analisador sintático da linguagem COOL, todas as alterações de expressões foram comentadas para mais detalhes e também foram criados e adicionados mais testes em programas funcionais.

Para a descrição geral dos terminais e não terminais da linguagem foi possível através da descrição que se encontra na `Figura 1 : Cool Syntax` em adicional aos tópicos abordados de forma específica em algumas seções do Manual de Cool, para a descrição da sintaxe em Bison foi necessário observar os exemplos e descrições, além disso, é importante salientar que as devidas referências foram adicionas ao código.

Para o `let` seguimos a descrição encontrada no manual, além disso, adicionamos algumas tratativos de limpeza de lookahead para o parser prosseguir com a leitura, dos tokens e listar o máximo de erros possível. 

#### Testes Adicionais
Adicionamos alguns testes que representam validações de um analisador léxico para linguagem COOL e outros pedidos compartilhados na descrição do TP2.
```
./myparser ./tests/test1.cl 
./myparser ./tests/test2.cl
./myparser ./tests/stack.cl

gmake dotest
gmake dotest2
gmake dotest3
```


Checklist de requisitos:

- [x] Implementar um parser para a linguagem Cool.
- [x] Utilizar ferramentas como Bison (para C++) ou CUP (para Java) para gerar o parser.
- [x] Construir uma Abstract Syntax Tree (AST) como saída do parser.
- [x] Consultar documentação online para entender o funcionamento de Bison, CUP e do pacote de manipulação de árvores.
- [x] Utilizar a versão em C++ do pacote para manipulação de árvores, descrita no material de Suporte para Implementação da Linguagem Cool.
- [x] Trabalhar em grupo de até 5 pessoas, se desejado.
- [x] Ler atentamente e compreender completamente a especificação para desenvolver um parser funcional.
- [x] Garantir que o scanner (analisador léxico) esteja funcionando corretamente.
- [x] Opção de utilizar sua própria implementação de scanner desenvolvida no trabalho anterior ou a versão oficial fornecida com o compilador coolc.
- [x] Substituir o executável do scanner (lexer) pela sua própria implementação, se necessário.
- [x] Não assumir automaticamente que o scanner utilizado está livre de erros; erros ocultos no scanner podem causar problemas no comportamento do parser.
- [x] Criar e utilizar um script chamado "myparser" que realize chamadas para o scanner e o parser.
- [x] Utilizar a opção "-p" no "myparser" para depurar o parser e imprimir informações úteis na saída padrão.
- [x] Examinar o arquivo "cool.output" gerado pelo Bison ou CUP, que contém uma listagem legível das tabelas sintáticas LALR(1), para depurar a definição do parser.
- [x] Testar o compilador em entradas "boas" e "ruins" para verificar se tudo está funcionando corretamente.
- [x] Lembrar que os erros na definição do parser podem se manifestar em qualquer lugar, portanto é importante testar amplamente.
- [x] Testar o parser com a versão oficial do analisador léxico (scanner) do compilador coolc antes de entregar a tarefa, pois o parser será avaliado usando esta versão.
- [?] Especificar um conjunto de ações semânticas para construir uma Abstract Syntax Tree (AST).
- [x] Garantir que a raiz da AST seja do tipo "program".
- [x] Para programas analisados com sucesso, a saída do parser deve ser uma listagem da AST.
- [x] Para programas com erros, a saída deve consistir das mensagens de erro do parser, conforme o formato padrão.
- [x] Não modificar a rotina de informe de erros fornecida, que imprime/exibe mensagens de erro em um formato padrão.
- [x] Não invocar diretamente a rotina de informe de erros nas ações semânticas; Bison/CUP a invocará automaticamente quando um problema for detectado.
- [x] Garantir que o parser funcione apenas para programas contidos em um único arquivo; não é necessário lidar com a compilação de múltiplos arquivos.
- [x] Verificar se o código está no arquivo `cool.flex` para implementação em C++ (ou `cool.lex` para implementação em Java) e se ele compila e funciona corretamente.
- [x] Explicar os comentários de nas linhas importantes.
- [x] Referenciar ia estrutura sintática da linguagem Cool, conforme descrita no Manual de Referência de Cool.
- [x] A ambiguidade na construção `let` da linguagem Cool deve ser resolvida garantindo que uma expressão `let` se estenda o mais à direita possível(Olhar no Manual e referenciar).
- [x] Editar o final do arquivo README, fornecendo anotações sobre o projeto, explicando decisões de design, a correção do código e a adequação dos casos de teste. Certificar-se de explicar de forma clara e concisa, além de comentar o código. Apenas alterar o arquivo fornecido.
- [ ] Compactar e codificar o subdiretório `PA3`, por exemplo, usando os comandos:
  ```
    bash
    tar cvzf PA3.tar.gz PA3 && uuencode PA3.tar.gz PA3.tar.gz > PA3.u && rm PA3.tar.gz
  ```
- [ ] Entregar o arquivo `PA3.u` via Canvas.

